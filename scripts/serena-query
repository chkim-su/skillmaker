#!/usr/bin/env python3
"""
serena-query: Serena daemon ì¿¼ë¦¬ ë„êµ¬ (ì»¨í…ìŠ¤íŠ¸ ê²©ë¦¬)

ì‚¬ìš©ë²•:
  serena-query <tool> [args...] [--output FILE]

ì˜ˆì‹œ:
  serena-query list_dir .
  serena-query get_symbols_overview src/main.py --depth 1
  serena-query find_symbol UserService --path src/
  serena-query search_for_pattern "class.*Service" --output /tmp/result.json
"""

import asyncio
import json
import sys
from pathlib import Path
from typing import Any

try:
    import httpx
except ImportError:
    print("ERROR: pip install httpx", file=sys.stderr)
    sys.exit(1)


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# MCP Client
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

async def call_serena(tool: str, params: dict, timeout: float = 60.0) -> dict:
    """Serena daemon SSE í˜¸ì¶œ"""

    base_url = "http://localhost:8765"
    session_id = None
    initialized = False
    tool_sent = False
    msg_id = 0

    async with httpx.AsyncClient(timeout=timeout) as client:
        async with client.stream("GET", f"{base_url}/sse") as sse:
            async for line in sse.aiter_lines():
                # 1. session_id íšë“ + ì´ˆê¸°í™”
                if not session_id and line.startswith("data: ") and "session_id=" in line:
                    session_id = line.split("session_id=")[1]
                    msg_id += 1
                    init_msg = {
                        "jsonrpc": "2.0", "id": msg_id, "method": "initialize",
                        "params": {
                            "protocolVersion": "2024-11-05",
                            "capabilities": {},
                            "clientInfo": {"name": "serena-query", "version": "0.1.0"}
                        }
                    }
                    await client.post(f"{base_url}/messages/?session_id={session_id}", json=init_msg)
                    continue

                if not line.startswith("data: "):
                    continue

                try:
                    data = json.loads(line[6:])
                except:
                    continue

                # 2. ì´ˆê¸°í™” ì‘ë‹µ â†’ ë„êµ¬ í˜¸ì¶œ
                if not initialized and data.get("id") == 1:
                    initialized = True
                    await client.post(f"{base_url}/messages/?session_id={session_id}",
                                     json={"jsonrpc": "2.0", "method": "notifications/initialized"})
                    msg_id += 1
                    await client.post(f"{base_url}/messages/?session_id={session_id}",
                                     json={"jsonrpc": "2.0", "id": msg_id, "method": "tools/call",
                                           "params": {"name": tool, "arguments": params}})
                    tool_sent = True
                    continue

                # 3. ê²°ê³¼ ìˆ˜ì‹ 
                if tool_sent and data.get("id") == msg_id:
                    return data

    return {"error": "timeout"}


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Structured Extractors (ë„êµ¬ë³„ êµ¬ì¡°í™” ì¶”ì¶œ)
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def extract_content(data: dict) -> Any:
    """MCP ì‘ë‹µì—ì„œ content ì¶”ì¶œ"""
    if "error" in data:
        return {"_error": data["error"]}

    result = data.get("result", {})
    text = result.get("content", [{}])[0].get("text", "")

    try:
        return json.loads(text)
    except:
        return text


def format_list_dir(content: Any) -> str:
    """list_dir ê²°ê³¼ í¬ë§·"""
    if isinstance(content, dict) and "_error" in content:
        return f"Error: {content['_error']}"

    if not isinstance(content, dict):
        return str(content)[:200]

    dirs = content.get("dirs", [])
    files = content.get("files", [])

    # ì¤‘ìš” ë””ë ‰í† ë¦¬/íŒŒì¼ í•˜ì´ë¼ì´íŠ¸
    important_dirs = [d for d in dirs if not d.startswith(".")]
    hidden_dirs = [d for d in dirs if d.startswith(".")]

    lines = [f"ğŸ“ Dirs({len(dirs)}): {', '.join(important_dirs[:8])}"]
    if len(important_dirs) > 8:
        lines[0] += f" +{len(important_dirs)-8} more"
    if hidden_dirs:
        lines.append(f"   Hidden: {', '.join(hidden_dirs[:5])}")

    # íŒŒì¼ì€ í™•ì¥ìë³„ ê·¸ë£¹í•‘
    by_ext: dict[str, list] = {}
    for f in files:
        ext = Path(f).suffix or "(no ext)"
        by_ext.setdefault(ext, []).append(f)

    file_summary = ", ".join(f"{ext}({len(fs)})" for ext, fs in sorted(by_ext.items()))
    lines.append(f"ğŸ“„ Files({len(files)}): {file_summary}")

    return "\n".join(lines)


def format_symbols_overview(content: Any) -> str:
    """get_symbols_overview ê²°ê³¼ í¬ë§·"""
    if isinstance(content, dict) and "_error" in content:
        return f"Error: {content['_error']}"

    if not isinstance(content, list):
        return str(content)[:200]

    # ì¢…ë¥˜ë³„ ê·¸ë£¹í•‘
    by_kind: dict[str, list] = {}
    for sym in content:
        kind = sym.get("kind", "Unknown")
        name = sym.get("name", "?")
        by_kind.setdefault(kind, []).append(name)

    lines = []
    for kind, names in sorted(by_kind.items()):
        if len(names) <= 5:
            lines.append(f"{kind}({len(names)}): {', '.join(names)}")
        else:
            lines.append(f"{kind}({len(names)}): {', '.join(names[:5])} +{len(names)-5}")

    return "\n".join(lines) or "No symbols found"


def format_find_symbol(content: Any) -> str:
    """find_symbol ê²°ê³¼ í¬ë§·"""
    if isinstance(content, dict) and "_error" in content:
        return f"Error: {content['_error']}"

    if not isinstance(content, list):
        return str(content)[:200]

    if not content:
        return "No symbols found"

    lines = []
    for sym in content[:10]:  # ìµœëŒ€ 10ê°œ
        name = sym.get("name_path", sym.get("name", "?"))
        kind = sym.get("kind", "?")
        path = sym.get("relative_path", "")
        loc = sym.get("body_location", {})
        start = loc.get("start_line", "?")
        end = loc.get("end_line", "?")

        lines.append(f"â€¢ {name} [{kind}] @ {path}:{start}-{end}")

    if len(content) > 10:
        lines.append(f"  ... +{len(content)-10} more")

    return "\n".join(lines)


def format_search_pattern(content: Any) -> str:
    """search_for_pattern ê²°ê³¼ í¬ë§·"""
    if isinstance(content, dict) and "_error" in content:
        return f"Error: {content['_error']}"

    if isinstance(content, str):
        # í…ìŠ¤íŠ¸ ê²°ê³¼
        lines = content.strip().split("\n")
        if len(lines) <= 5:
            return content
        return "\n".join(lines[:5]) + f"\n... +{len(lines)-5} lines"

    if isinstance(content, dict):
        # íŒŒì¼ë³„ ë§¤ì¹­
        total = sum(len(v) if isinstance(v, list) else 1 for v in content.values())
        files = list(content.keys())[:5]
        result = f"Matches({total}) in {len(content)} files:\n"
        result += "\n".join(f"  â€¢ {f}" for f in files)
        if len(content) > 5:
            result += f"\n  ... +{len(content)-5} files"
        return result

    return str(content)[:200]


def format_find_references(content: Any) -> str:
    """find_referencing_symbols ê²°ê³¼ í¬ë§·"""
    if isinstance(content, dict) and "_error" in content:
        return f"Error: {content['_error']}"

    if not isinstance(content, list):
        return str(content)[:200]

    if not content:
        return "No references found"

    # íŒŒì¼ë³„ ê·¸ë£¹í•‘
    by_file: dict[str, int] = {}
    for ref in content:
        path = ref.get("relative_path", "unknown")
        by_file[path] = by_file.get(path, 0) + 1

    lines = [f"References({len(content)}) in {len(by_file)} files:"]
    for path, count in sorted(by_file.items(), key=lambda x: -x[1])[:5]:
        lines.append(f"  â€¢ {path}: {count}")
    if len(by_file) > 5:
        lines.append(f"  ... +{len(by_file)-5} files")

    return "\n".join(lines)


def format_generic(content: Any) -> str:
    """ê¸°ë³¸ í¬ë§·í„°"""
    if isinstance(content, dict) and "_error" in content:
        err = content["_error"]
        if isinstance(err, dict):
            return f"Error: {err.get('message', err)}"
        return f"Error: {err}"

    if isinstance(content, list):
        return f"Items: {len(content)}"
    if isinstance(content, dict):
        return f"Keys: {', '.join(list(content.keys())[:10])}"
    if isinstance(content, str):
        lines = content.split("\n")
        return f"Lines: {len(lines)}"

    return str(content)[:200]


# ë„êµ¬ë³„ í¬ë§·í„° ë§¤í•‘
FORMATTERS = {
    "list_dir": format_list_dir,
    "get_symbols_overview": format_symbols_overview,
    "find_symbol": format_find_symbol,
    "search_for_pattern": format_search_pattern,
    "find_referencing_symbols": format_find_references,
}


def format_location(content: Any) -> str:
    """ìœ„ì¹˜ ì •ë³´ë§Œ ì¶”ì¶œ - Read ë„êµ¬ì™€ ì§ì ‘ ì—°ê³„"""
    if isinstance(content, dict) and "_error" in content:
        return f"Error: {content['_error']}"

    if not isinstance(content, list):
        return ""

    lines = []
    for item in content:
        path = item.get("relative_path", "")
        loc = item.get("body_location", item.get("location", {}))
        start = loc.get("start_line", loc.get("line", "?"))
        end = loc.get("end_line", start)
        if path:
            lines.append(f"{path}:{start}:{end}")

    return "\n".join(lines)


def summarize(tool: str, data: dict, mode: str = "summary") -> str:
    """ë„êµ¬ë³„ êµ¬ì¡°í™” ìš”ì•½"""
    content = extract_content(data)

    # ëª¨ë“œë³„ ì²˜ë¦¬
    if mode == "full":
        return json.dumps(content, indent=2, ensure_ascii=False)
    elif mode == "location":
        return format_location(content)

    # ê¸°ë³¸: summary ëª¨ë“œ
    formatter = FORMATTERS.get(tool, format_generic)
    return formatter(content)


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# CLI
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

def parse_args():
    """ê°„ë‹¨í•œ ì¸ì íŒŒì‹±"""
    args = sys.argv[1:]

    if not args or args[0] in ("-h", "--help"):
        print(__doc__)
        sys.exit(0)

    tool = args[0]
    output = None
    mode = "summary"  # summary, location, full
    params = {}

    i = 1
    positional_idx = 0
    positional_map = {
        "list_dir": ["relative_path"],
        "get_symbols_overview": ["relative_path"],
        "find_symbol": ["name_path_pattern"],
        "find_file": ["file_mask", "relative_path"],
        "search_for_pattern": ["substring_pattern"],
        "find_referencing_symbols": ["name_path", "relative_path"],
        "read_file": ["relative_path"],
    }

    positional_keys = positional_map.get(tool, ["relative_path"])

    while i < len(args):
        arg = args[i]

        if arg == "--output" and i + 1 < len(args):
            output = args[i + 1]
            i += 2
        elif arg == "--mode" and i + 1 < len(args):
            mode = args[i + 1]
            i += 2
        elif arg.startswith("--"):
            key = arg[2:].replace("-", "_")
            if i + 1 < len(args) and not args[i + 1].startswith("--"):
                val = args[i + 1]
                # íƒ€ì… ë³€í™˜
                if val.lower() == "true":
                    val = True
                elif val.lower() == "false":
                    val = False
                elif val.isdigit():
                    val = int(val)
                params[key] = val
                i += 2
            else:
                params[key] = True
                i += 1
        else:
            # Positional argument
            if positional_idx < len(positional_keys):
                params[positional_keys[positional_idx]] = arg
                positional_idx += 1
            i += 1

    # ê¸°ë³¸ê°’ ì„¤ì •
    if tool == "list_dir" and "recursive" not in params:
        params["recursive"] = False

    return tool, params, output, mode


async def main():
    tool, params, output, mode = parse_args()

    if not params:
        print(f"Error: No parameters for {tool}", file=sys.stderr)
        sys.exit(1)

    # Serena í˜¸ì¶œ
    result = await call_serena(tool, params)

    # ì „ì²´ ê²°ê³¼ ì €ì¥
    if output:
        Path(output).write_text(json.dumps(result, indent=2, ensure_ascii=False))

    # ëª¨ë“œë³„ ì¶œë ¥
    print(summarize(tool, result, mode))


if __name__ == "__main__":
    asyncio.run(main())
